// Type definitions for Google Ad Manager (GAM) data collection
// Generated by Gemini, refined for ad-tech-analyzer

/**
 * Represents the response information for a specific slot.
 */
export interface GamResponseInfo {
  advertiserId: number | null;
  campaignId: number | null;
  creativeId: number | null;
  lineItemId: number | null;
  labelIds: number[];
}

/**
 * Represents a single ad slot defined in GAM.
 */
export interface GamSlot {
  slotId: string;
  adUnitPath: string;
  sizes: (string | number[])[];
  targeting: Record<string, string[]>;
  responseInformation?: GamResponseInfo | null;
}

/**
 * Represents page-level targeting and configuration.
 */
export interface GamPageSettings {
  targeting: Record<string, string[]>;
  attributeKeys: string[];
  version: string;
}

/**
 * The main interface for collected GAM data.
 */
export interface GamData {
  slots: GamSlot[];
  pageSettings: GamPageSettings;
  enabledServices: string[];
}

/**
 * Extracts relevant GAM data from the window.googletag object.
 *
 * @returns {GamData | null} The collected GAM data, or null if googletag is not available.
 */
export function extractGAMData(): GamData | null {
  if (typeof window === 'undefined' || !window.googletag) {
    console.warn('[GAM Collector] window.googletag not found. Cannot extract GAM data.');
    return null;
  }

  const googletag = window.googletag;

  // GAM may only have cmd stub if not fully loaded
  // We need to call extraction inside cmd queue to ensure GAM is ready
  let gamDataResult: GamData | null = null;

  const gamData: Partial<GamData> = {};

  try {
    const pubads = googletag.pubads();
    
    // --- Page Settings ---
    const pageSettings: Partial<GamPageSettings> = {};
    
    // Version
    try {
        pageSettings.version = typeof googletag.getVersion === 'function' ? googletag.getVersion() : 'unknown';
    } catch (e) {
        console.warn('[GAM Collector] Error getting version:', e);
        pageSettings.version = 'unknown';
    }

    // Page Level Targeting
    try {
        const targetingKeys = pubads.getTargetingKeys ? pubads.getTargetingKeys() : [];
        const targeting: Record<string, string[]> = {};
        targetingKeys.forEach((key: string) => {
            targeting[key] = pubads.getTargeting(key);
        });
        pageSettings.targeting = targeting;
    } catch (e) {
        console.error('[GAM Collector] Error getting page targeting:', e);
        pageSettings.targeting = {};
    }

    // Attributes
    try {
        pageSettings.attributeKeys = pubads.getAttributeKeys ? pubads.getAttributeKeys() : [];
    } catch (e) {
        console.error('[GAM Collector] Error getting attribute keys:', e);
        pageSettings.attributeKeys = [];
    }
    
    gamData.pageSettings = pageSettings as GamPageSettings;


    // --- Slots ---
    try {
        const slots = pubads.getSlots ? pubads.getSlots() : [];
        gamData.slots = slots.map((slot: any) => {
            const slotData: GamSlot = {
                slotId: slot.getSlotElementId(),
                adUnitPath: slot.getAdUnitPath(),
                sizes: [],
                targeting: {},
                responseInformation: null
            };
            
            // Sizes
            try {
                const sizes = slot.getSizes();
                if (Array.isArray(sizes)) {
                     slotData.sizes = sizes.map((s: any) => {
                        if (typeof s === 'object' && s !== null && 'getWidth' in s && 'getHeight' in s) {
                            return [s.getWidth(), s.getHeight()];
                        }
                        if (s === 'fluid') return 'fluid';
                        return s; // Fallback
                     });
                }
            } catch (e) {
                // Ignore size extraction errors for specific slot
            }

            // Targeting
            try {
                const keys = slot.getTargetingKeys();
                keys.forEach((key: string) => {
                    slotData.targeting[key] = slot.getTargeting(key);
                });
            } catch (e) {
                // Ignore targeting errors
            }

            // Response Info
            try {
                const resp = slot.getResponseInformation();
                if (resp) {
                    slotData.responseInformation = {
                        advertiserId: resp.advertiserId,
                        campaignId: resp.campaignId,
                        creativeId: resp.creativeId,
                        lineItemId: resp.lineItemId,
                        labelIds: resp.labelIds || []
                    };
                }
            } catch (e) {
                // Ignore response info errors (e.g. if slot hasn't fetched yet)
            }

            return slotData;
        });
    } catch (e) {
        console.error('[GAM Collector] Error getting slots:', e);
        gamData.slots = [];
    }
    
    // --- Enabled Services ---
    // Minimal check for services
    gamData.enabledServices = [];
    if (googletag.pubads) gamData.enabledServices.push('pubads');
    if (googletag.companionAds) gamData.enabledServices.push('companionAds');
    if (googletag.content) gamData.enabledServices.push('content');

  } catch (error) {
    console.error('[GAM Collector] General error extracting GAM data:', error);
    return null;
  }

  return gamData as GamData;
}

// Augment the Window interface to include googletag
declare global {
  interface Window {
    googletag?: {
        cmd: any[];
        pubads: () => {
            getSlots: () => any[];
            getTargetingKeys: () => string[];
            getTargeting: (key: string) => string[];
            getAttributeKeys: () => string[];
            [key: string]: any;
        };
        getVersion?: () => string;
        companionAds?: any;
        content?: any;
        [key: string]: any;
    };
  }
}
